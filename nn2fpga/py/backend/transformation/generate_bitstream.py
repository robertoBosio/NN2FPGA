from qonnx.transformation.base import Transformation
from qonnx.core.modelwrapper import ModelWrapper
from qonnx.custom_op.registry import getCustomOp
from backend.core.acceleratorpackage import AcceleratorPackage
from backend.util.board_util import read_board_info
import base64
import os
import subprocess

def dump_tcl_script(top_name, part_name, frequency, hls_version):
    """Dump a TCL script to set up the HLS project and run the simulation."""

    t_clk = f"{1e3 / int(frequency):.2f}ns" # Convert frequency in MHz to clock period in ns
    lines = list()
    lines.append("# Auto-generated TCL script for HLS project setup")
    lines.append("# Generated by nn2FPGA simulation flow")
    lines.append("")

    # Check the HLS version to determine the correct syntax
    if float(hls_version) > 2025:
        lines.append(
            'open_component -reset "hlsproj_{top_name}" -flow_target vivado',
        )
    else:
        lines.extend(
            [
                'open_project -reset "hlsproj_{top_name}"',
                'open_solution -reset solution0',
            ]
        )

    lines.extend(
        [
            'add_files kernel.cpp -cflags " -I/workspace/NN2FPGA/nn2fpga/library/include"',
            'set_top "{top_name}"',
            'set_part {part_name}',
            'create_clock -period {t_clk}',
            'config_compile -pipeline_style frp -enable_auto_rewind=false',
            'csynth_design',
            'export_design -format ip_catalog -ipname "{top_name}" -library "ml" -vendor "polito.nn2FPGA" -version "1.0" -description "Generated by nn2FPGA"',
            'exit',
        ]
    )

    return "\n".join(lines).format(
        top_name=top_name, part_name=part_name, t_clk=t_clk
    )

def vivado_tcl_script(
    work_dir: str,
    top_name: str,
    part_name: str,
    board_part_name: str,
    frequency: int,
    hls_version: str,
    axilite_base_addr: int,
    axilite_dma_window: int,
    interface_width: int,
    inputs: list,
    outputs: list,
) -> str:
    """Generate a Vivado TCL script for the HLS project setup."""

    lines = list()
    lines.append("# Auto-generated Vivado TCL script for bitstream generation")
    lines.append("# Generated by nn2FPGA simulation flow")
    lines.append("")

    # Project creation and setup
    lines.append(f'create_project vivadoproj_{top_name} {work_dir}/vivadoproj_{top_name} -part {part_name} -force') 
    lines.append(f'set_property board_part {board_part_name} [current_project]')

    # Add HLS IP
    lines.append(f'set_property ip_repo_paths {work_dir}/hlsproj_{top_name} [current_project]')
    lines.append(f'update_ip_catalog')
    lines.append(f'set ip_found [llength [get_ipdefs -filter \"NAME == {top_name}\"]]')
    lines.append(f'if {{$ip_found == 0}} {{')
    lines.append(f'  puts \"Error: IP {top_name} not found in catalog\"')
    lines.append(f'  exit 1')
    lines.append(f'}}')

    # Create the block design
    lines.append(f'create_bd_design "{top_name}_bd"')

    # Add the PS block
    lines.append(
        f"create_bd_cell -type ip -vlnv xilinx.com:ip:zynq_ultra_ps_e:3.5 zynq_ultra_ps_e_0"
    )
    lines.append(
        f'apply_bd_automation -rule xilinx.com:bd_rule:zynq_ultra_ps_e -config {{apply_board_preset "1" }}  [get_bd_cells zynq_ultra_ps_e_0]'
    )
    lines.extend(
        [
            "set_property -dict [list \\",
            f"  CONFIG.PSU__FPGA_PL1_ENABLE {{{0}}} \\",
            f"  CONFIG.PSU__CRL_APB__PL0_REF_CTRL__FREQMHZ {{{frequency}}} \\",
            f"  CONFIG.PSU__USE__M_AXI_GP1 {{{0}}} \\",
            f"  CONFIG.PSU__USE__S_AXI_GP2 {{{1}}} \\",
            f"  CONFIG.PSU__USE__S_AXI_GP3 {{{1}}} \\",
            f"  CONFIG.PSU__USE__S_AXI_GP4 {{{1}}} \\",
            f"  CONFIG.PSU__USE__S_AXI_GP5 {{{1}}} \\",
            f"  CONFIG.PSU__USE__IRQ0 {{{0}}} \\",
            "] [get_bd_cells zynq_ultra_ps_e_0]",
        ]
    )

    # Add the HLS IP block
    lines.append(
        f'create_bd_cell -type ip -vlnv polito.nn2FPGA:ml:{top_name}:1.0 {top_name}_0'
    )

    # Add the Process System Reset
    lines.append(
        f'create_bd_cell -type ip -vlnv xilinx.com:ip:proc_sys_reset:5.0 proc_sys_reset_0'
    )

    # Add DMAs
    for input, _ in inputs:
        lines.append(
            f'create_bd_cell -type ip -vlnv xilinx.com:ip:axi_dma:7.1 {input}_dma'
        )
        lines.append(
            f'set_property -dict [list CONFIG.C_INCLUDE_MM2S {{{1}}} CONFIG.C_INCLUDE_S2MM {{{0}}} CONFIG.C_INCLUDE_SG {{{0}}} CONFIG.C_SG_LENGTH_WIDTH {{{26}}}] [get_bd_cells {input}_dma]'
        )
        lines.append(f'set_property -dict [list CONFIG.C_M_AXI_MM2S_DATA_WIDTH {{{interface_width}}} CONFIG.C_M_AXIS_MM2S_TDATA_WIDTH {{{interface_width}}}] [get_bd_cells {input}_dma]')

    for output, _ in outputs:
        lines.append(
            f'create_bd_cell -type ip -vlnv xilinx.com:ip:axi_dma:7.1 {output}_dma'
        )
        lines.append(
            f"set_property -dict [list CONFIG.C_INCLUDE_MM2S {{{0}}} CONFIG.C_INCLUDE_S2MM {{{1}}} CONFIG.C_INCLUDE_SG {{{1}}} CONFIG.C_SG_LENGTH_WIDTH {{{26}}} CONFIG.C_SG_INCLUDE_STSCNTRL_STRM {{{0}}}] [get_bd_cells {output}_dma]"
        )
        lines.append(f'set_property -dict [list CONFIG.C_M_AXI_S2MM_DATA_WIDTH {{{interface_width}}} CONFIG.C_S_AXIS_S2MM_TDATA_WIDTH {{{interface_width}}}] [get_bd_cells {output}_dma]')

    # Add smartconnect for AXI lite interfaces
    lines.append(f'create_bd_cell -type ip -vlnv xilinx.com:ip:smartconnect:1.0 smartconnect_axilite_0')
    lines.append(f'set_property -dict [list CONFIG.NUM_SI {{{1}}} CONFIG.NUM_MI {{{len(inputs) + len(outputs)}}}] [get_bd_cells smartconnect_axilite_0]')

    # Add smartconnect for scatter-gather interfaces
    lines.append(f'create_bd_cell -type ip -vlnv xilinx.com:ip:smartconnect:1.0 smartconnect_sg_0')
    lines.append(f'set_property -dict [list CONFIG.NUM_SI {{{len(outputs)}}} CONFIG.NUM_MI {{{1}}}] [get_bd_cells smartconnect_sg_0]')

    # Connect clock to every block
    lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins {top_name}_0/ap_clk]')
    lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins proc_sys_reset_0/slowest_sync_clk]')
    lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins smartconnect_axilite_0/aclk]')
    lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins smartconnect_sg_0/aclk]')
    lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins zynq_ultra_ps_e_0/maxihpm0_fpd_aclk]')
    lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins zynq_ultra_ps_e_0/saxihp0_fpd_aclk]')
    lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins zynq_ultra_ps_e_0/saxihp1_fpd_aclk]')
    lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins zynq_ultra_ps_e_0/saxihp2_fpd_aclk]')
    lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins zynq_ultra_ps_e_0/saxihp3_fpd_aclk]')
    for input, _ in inputs:
        lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins {input}_dma/s_axi_lite_aclk]')
        lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins {input}_dma/m_axi_mm2s_aclk]')
    for output, _ in outputs:
        lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins {output}_dma/s_axi_lite_aclk]')
        lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins {output}_dma/m_axi_s2mm_aclk]')
        lines.append(f'connect_bd_net -net ps_clk [get_bd_pins zynq_ultra_ps_e_0/pl_clk0] [get_bd_pins {output}_dma/m_axi_sg_aclk]')

    # Connect reset to every block
    lines.append(f'connect_bd_net -net ps_rst [get_bd_pins proc_sys_reset_0/ext_reset_in] [get_bd_pins zynq_ultra_ps_e_0/pl_resetn0]')
    lines.append(f'connect_bd_net -net a_rst [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins {top_name}_0/ap_rst_n]')
    lines.append(f'connect_bd_net -net a_rst [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins smartconnect_axilite_0/aresetn]')
    lines.append(f'connect_bd_net -net a_rst [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins smartconnect_sg_0/aresetn]')
    for input, _ in inputs:
        lines.append(f'connect_bd_net -net a_rst [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins {input}_dma/axi_resetn]')
    for output, _ in outputs:
        lines.append(f'connect_bd_net -net a_rst [get_bd_pins proc_sys_reset_0/peripheral_aresetn] [get_bd_pins {output}_dma/axi_resetn]')

    # Connect AXI lite interfaces to the smartconnect
    for i, (input, _) in enumerate(inputs):
        lines.append(f'connect_bd_intf_net -intf_net {input}_axi_lite [get_bd_intf_pins {input}_dma/S_AXI_LITE] [get_bd_intf_pins smartconnect_axilite_0/M0{i}_AXI]')
    for i, (output, _) in enumerate(outputs):
        lines.append(f'connect_bd_intf_net -intf_net {output}_axi_lite [get_bd_intf_pins {output}_dma/S_AXI_LITE] [get_bd_intf_pins smartconnect_axilite_0/M0{i + len(inputs)}_AXI]')

    # Connect SmartConnect AXI interfaces to the PS
    lines.append(f'connect_bd_intf_net -intf_net ps_axilite [get_bd_intf_pins zynq_ultra_ps_e_0/M_AXI_HPM0_FPD] [get_bd_intf_pins smartconnect_axilite_0/S00_AXI]')

    # Connect HLS IP streams to the DMAs
    for input, _ in inputs:
        lines.append(f'connect_bd_intf_net -intf_net {input}_axis [get_bd_intf_pins {top_name}_0/{input}_stream] [get_bd_intf_pins {input}_dma/M_AXIS_MM2S]')
    for output, _ in outputs:
        lines.append(f'connect_bd_intf_net -intf_net {output}_axis [get_bd_intf_pins {top_name}_0/{output}_stream] [get_bd_intf_pins {output}_dma/S_AXIS_S2MM]')

    # Connect DMAs to PS
    for i, (input, _) in enumerate(inputs):
        lines.append(f'connect_bd_intf_net -intf_net {input}_maxi [get_bd_intf_pins zynq_ultra_ps_e_0/S_AXI_HP{i}_FPD] [get_bd_intf_pins {input}_dma/M_AXI_MM2S]')
    for i, (output, _) in enumerate(outputs):
        lines.append(f'connect_bd_intf_net -intf_net {output}_maxi [get_bd_intf_pins zynq_ultra_ps_e_0/S_AXI_HP{i + len(inputs)}_FPD] [get_bd_intf_pins {output}_dma/M_AXI_S2MM]')

    # Connect scatter-gather DMA to the smartconnect
    for i, (output, _) in enumerate(outputs):
        lines.append(f'connect_bd_intf_net -intf_net {output}_sg [get_bd_intf_pins {output}_dma/M_AXI_SG] [get_bd_intf_pins smartconnect_sg_0/S0{i}_AXI]')
    
    # Connect smartconnect scatter-gather to the PS
    lines.append(f'connect_bd_intf_net -intf_net ps_sg [get_bd_intf_pins zynq_ultra_ps_e_0/S_AXI_HP{len(inputs) + len(outputs)}_FPD] [get_bd_intf_pins smartconnect_sg_0/M00_AXI]')

    # Assign addresses to the PS interfaces
    lines.append(f'assign_bd_address')

    # Reduce the axi_lite range of DMAs to 4 KiB
    axilite_window_str = f"{axilite_dma_window / 1024}K"
    for input, offset in inputs:
        lines.append(f'set_property range 4K [get_bd_addr_segs {{zynq_ultra_ps_e_0/Data/SEG_{input}_dma_Reg}}]')
        lines.append(f'set_property offset 0x{(axilite_base_addr + offset):X} [get_bd_addr_segs {{zynq_ultra_ps_e_0/Data/SEG_{input}_dma_Reg}}]')
    for output, offset in outputs:
        lines.append(f'set_property range 4K [get_bd_addr_segs {{zynq_ultra_ps_e_0/Data/SEG_{output}_dma_Reg}}]')
        lines.append(f'set_property offset 0x{(axilite_base_addr + offset):X} [get_bd_addr_segs {{zynq_ultra_ps_e_0/Data/SEG_{output}_dma_Reg}}]')

    # Validate the block design
    lines.append(f'validate_bd_design')

    # Save the block design
    lines.append(f'save_bd_design')

    # Make wrapper
    lines.append(f'make_wrapper -files [get_files {work_dir}/vivadoproj_{top_name}/vivadoproj_{top_name}.srcs/sources_1/bd/{top_name}_bd/{top_name}_bd.bd] -top')
    lines.append(f'add_files -norecurse {work_dir}/vivadoproj_{top_name}/vivadoproj_{top_name}.gen/sources_1/bd/{top_name}_bd/hdl/{top_name}_bd_wrapper.v')
    lines.append(f'set_property top {top_name}_bd [current_fileset]')
    lines.append(f'update_compile_order -fileset sources_1')

    # Launch synthesis
    lines.append(f'launch_runs synth_1 -jobs 8')
    lines.append(f'wait_on_run synth_1')

    # Launch implementation
    lines.append(f'launch_runs impl_1 -to_step write_bitstream -jobs 8')
    lines.append(f'wait_on_run impl_1')

    return "\n".join(lines)


def make_build_dir(work_dir: str) -> None:
    """Create the working directory for the simulation."""
    os.makedirs(work_dir, exist_ok=True)

class GenerateBitstream(Transformation):

    def __init__(
        self,
        work_dir: str,
        erase: bool = True,
        axilite_dma_window: int = 4096,
    ):
        super().__init__()
        self.work_dir = work_dir
        self.erase = erase

        # Check axilite_dma_window is a power of two
        if axilite_dma_window & (axilite_dma_window - 1) != 0:
            raise ValueError("axilite_dma_window must be a power of two.")

        # Check axilite has not an unreasonable size.
        # This is not a strict requirement, probably DMA can even fit in less space.
        if axilite_dma_window < 1024 or axilite_dma_window > 65536:
            raise ValueError("axilite_dma_window must be between 1K and 64K bytes.")

        # Set the axilite parameters
        self.axilite_dma_window = axilite_dma_window

    def apply(self, model: ModelWrapper) -> tuple[ModelWrapper, bool]:

        partition_node = model.get_nodes_by_op_type("nn2fpgaPartition")[0]
        ap = AcceleratorPackage.from_json(getCustomOp(partition_node).get_nodeattr("accelerator_package"))
        work_dir = ap.work_dir
        work_dir = f"{os.path.abspath(work_dir)}/vivado"
        make_build_dir(work_dir)

        top_name = model.get_metadata_prop("top_name")
        board = model.get_metadata_prop("board_name")
        frequency = model.get_metadata_prop("frequency")
        hls_version = model.get_metadata_prop("hls_version")
        axilite_size = int(model.get_metadata_prop("axilite_size"))
        axilite_address = int(model.get_metadata_prop("axilite_address"))
        interface_width = read_board_info(board)["axi_bitwidth"]
        part_name = read_board_info(board)["part"]
        board_part_name = read_board_info(board)["board_part"]

        if len(ap.input_map) + len(ap.output_map) * self.axilite_dma_window > axilite_size:
            raise ValueError(
                f"Total AXI lite size ({len(ap.input_map) + len(ap.output_map) * self.axilite_dma_window}) exceeds the maximum allowed size ({axilite_size})."
            )

        # Generate the TCL script
        tcl_script = dump_tcl_script(
            top_name=top_name,
            part_name=part_name,
            frequency=frequency,
            hls_version=hls_version,
        )

        # Write the TCL script to a file
        with open(f"{work_dir}/setup.tcl", "w") as f:
            f.write(tcl_script)

        # Write the HLS code to a file
        with open(f"{work_dir}/kernel.cpp", "w") as f:
            f.write(base64.b64decode(ap.hls_code_b64).decode())

        # Synthesize and export the design.
        subprocess.run(
            ["vitis_hls", "-f", f"{work_dir}/setup.tcl"],
            cwd=work_dir,
            check=True
        )

        # Retrieve input list and assign AXI offsets
        axi_offset = 0x0
        input_list = []
        inputs = ap.input_map
        for value in inputs.values():
            value["axi_offset"] = axi_offset
            input_list.append((value["new_name"], axi_offset))
            axi_offset += self.axilite_dma_window

        # Retrieve output list
        output_list = []
        outputs = ap.output_map
        for value in outputs.values():
            value["axi_offset"] = axi_offset
            output_list.append((value["new_name"], axi_offset))
            axi_offset += self.axilite_dma_window

        # Write the Vivado block design.
        with open(f"{work_dir}/vivado.tcl", "w") as f:
            f.write(
                vivado_tcl_script(
                    work_dir=work_dir,
                    top_name=top_name,
                    part_name=part_name,
                    board_part_name=board_part_name,
                    frequency=frequency,
                    hls_version=hls_version,
                    axilite_base_addr=axilite_address,
                    axilite_dma_window=self.axilite_dma_window,
                    interface_width=interface_width,
                    inputs=input_list,
                    outputs=output_list,
                )
            )

        # Run Vivado to generate the bitstream.
        subprocess.run(
            ["vivado", "-mode", "batch", "-source", f"{work_dir}/vivado.tcl"],
            cwd=work_dir,
            check=True
        )

        # Check if the bitstream was generated successfully.
        bitstream_path = f"{work_dir}/vivadoproj_{top_name}/vivadoproj_{top_name}.runs/impl_1/{top_name}_bd.bit"
        if not os.path.exists(bitstream_path):
            raise RuntimeError(f"Bitstream generation failed: {bitstream_path} does not exist.")

        # Set the bitstream in the accelerator package.
        ap.set_bitstream(bitstream_path)

        # Check the HWH file.
        hwh_path = f"{work_dir}/vivadoproj_{top_name}/vivadoproj_{top_name}.gen/sources_1/bd/{top_name}_bd/hw_handoff/{top_name}_bd.hwh"
        if not os.path.exists(hwh_path):
            raise RuntimeError(f"HWH file generation failed: {hwh_path} does not exist.")

        # Set the HWH file in the accelerator package.
        ap.set_hwh(hwh_path)

        # Update the accelerator package in the partition node.
        getCustomOp(partition_node).set_nodeattr("accelerator_package", ap.to_json())

        return model, False
